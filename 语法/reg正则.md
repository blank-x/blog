RegExp 的属性 $1, ..., $9

```
if (new RegExp("(f+)d+(s+)").test("ddfffdddsss")) { 
    alert(RegExp.$1 + ", " + RegExp.$2); // 提示出： fff, sss 
} 
```
# 元字符 

\d  匹配数字 

\s  匹配任意的空白符 

\w  匹配字母或数字或下划线   （js中\w不能匹配汉字） 

.     匹配除换行符以外的任意字符 

^    匹配字符串的开始 

$    匹配字符串的结束 


\f ： 换页符                     \n ： 换行符 

\r ： 回车符                     \t ： 制表(tab)符 

 [a-z0-9A-Z_]  === \w 

\W  匹配任意不是字母，数字，下划线，汉字的字符 

\S   匹配任意不是空白符的字符 

\D   匹配任意非数字的字符 

\B   匹配不是单词开头或结束的位置 

# 重复 

\*重复零次或更多次 

\+重复一次或更多次 

?         重复零次或一次 

{n}       重复n次 

{n,}      重复n次或更多次 

{n,m}     重复n到m次 



# 分枝条件 | 

0\d{2}-\d{8}|0\d{3}-\d{7} 

\d{5}-\d{4}|\d{5} 

# 分组 

重复多个字符 可以使用 

(\d{1,3}\.){3}\d{1,3} 

调换位置   一共$1--$9 

var myReg = /(\w+)\s*(\w+)/; 

var str  = "John Smith"; 

newstr = str.replace(myReg, "$2   sdfsdfsdf $1")   // "Smith   sdfsdfsdf John" 

# 反义 

[^x]  匹配除了x以外的任意字符 

[^aeiou]   匹配除了aeiou这几个字母以外的任意字符 

例子： 

\S+匹配不包含空白符的字符串。 

<a[^>]+>匹配用尖括号括起来的以a开头的字符串。 

# 后向引用 

回溯引用 

\1代表分组1匹配的文本    

/\b(\w+)\b\s+\1\b/.test('go go’)   \数字      表示捕获组,要求与第几个捕获组相同 

可以自己指定子表达式的组名 

\b(?<Word>\w+)\b\s+\k<Word>\b    和上面的功能一样   // .test('sdf  sdf') 

/<(\w+\d?)>.*<\/\1>/ 

分析：\1 引用的前面的第一个子模式 

<li><a href="https://liukanshan.zhihu.com" target="_blank">刘看山</a></li> 

<li><a href="/question/19581624" target="_blank">知乎指南</a></li> 

<li><a href="javascript:;" id="js-feedback-button">建议反馈</a></li> 

<li><a href="/app" target="_blank">移动应用</a></li> 

<li><a href="/careers">加入知乎</a></li> 

<li><a href="/terms" target="_blank">知乎协议</a></li> 

<li><a href="/contact">联系我们</a></li> 

var reg = /<(\w+\d?)>(.*)<\/\1>/g; 

str.match(reg); 

/*最后部分的\1便是一个回溯引用，引用的前面的第一个子模式(\w+\d?)，当然如果前面还存在第二个子模式我们也可以使用\2引用、。 注意：回溯引用只能引用前面已经匹配过的结果，而下面这样的写法就是错误的。 错误的例子： var reg = /<\1>.*?<\/(\w+\d?)>/gi; */ 

result: 

[ 0"<li><a href="https://liukanshan.zhihu.com" target="_blank">刘看山</a></li>" 

1:"<li><a href="/question/19581624" target="_blank">知乎指南</a></li>" 

2:"<li><a href="javascript:;" id="js-feedback-button">建议反馈</a></li>" 

3:"<li><a href="/app" target="_blank">移动应用</a></li>" 

4:"<li><a href="/careers">加入知乎</a></li>" 

5:"<li><a href="/terms" target="_blank">知乎协议</a></li>" 

6:"<li><a href="/contact">联系我们</a></li>”  ] 

# 捕获与非捕获 

(exp) 

'123sdf12312'.match(/(123)sdf/)    

结果： ["123sdf", "123", index: 0, input: "123sdf12312", groups: undefined] 

分析：分组 123 在匹配到结果里，属于捕获 

(?:exp) 

'123sdf12312'.match(/(?:123)sdf/)    

结果:  ["123sdf", index: 0, input: "123sdf12312", groups: undefined] 

分析：分组 123 不再结果里，非捕获   

(?<name>exp) 

‘123sdf12312’.match(/(?<haha>123)sdf/) 

结果： ["123sdf", "123", index: 0, input: "123sdf12312", groups: {…}] 

分析：结果略有不同，groups 是一个对象：{haha:'123'} 



# 零宽断言 

像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言 

(?=exp)  匹配exp前面的位置 

零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp 

'ring'.match(/\b\w+(?=ing\b)/) 

结果: ["r", index: 0, input: "ring", groups: undefined] 

//把99999999999，转成99,999,999,999 

var reg=/\d{1,3}(?=(\d{3})+$)/g; 

var str1='99999999999’; 

str1.replace(reg,'$&,’) 

result: 99,999,999,999 

industr(?:y|ies)  匹配 industry|industries 


(?<=exp)  匹配exp后面的位置 

\b\w+(?=ing\b)，会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading 

'reading'.match(/(?<=\bre)\w+\b/)   

结果：["ading", index: 2, input: "reading", groups: undefined] 


(?!exp)   匹配后面跟的不是exp的位置 

断言此位置的后面不能匹配表达式exp，它只匹配一个位置，并不消费任何字符 

'sdfqs'.match(/\w*q(?!u)\w/) 

结果：["sdfqs", index: 0, input: "sdfqs", groups: undefined] 

(?<!exp)  匹配前面不是exp的位置 

'A1231231sdfq'.match(/(?<![a-z])\d{7}/)  匹配前面不是小写字母的七位数字 

(?<=<(\w+)>).*(?=<\/\1>) 匹配不包含属性的简单HTML标签内里的内容 

# 贪婪与懒惰 

*?   重复任意次，但尽可能少重复 

+?   重复1次或更多次，但尽可能少重复 

??    重复0次或1次，但尽可能少重复 

{n,m}?   重复n到m次，但尽可能少重复 

{n,}?    重复n次以上，但尽可能少重复 

贪婪匹配        惰性匹配             匹配描述 

?              ??               匹配 0 个或 1 个 

\+             +?               匹配 1 个或多个 

\*             *?               匹配 0 个或多个 

{n}         {n}?             匹配 n 个 

{n,m}    {n,m}?           匹配 n 个或 m 个 

{n,}          {n,}?            匹配 n 个或多个      

a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。 

为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权——The match that begins earliest wins。 



# match 方法 

但是通过while循环，可以实现全局匹配， 

返回三个数组 

["test001", "001", index: 4, input: "now test001 test002 test111"] 

["test002", "002", index: 12, input: "now test001 test002 test111"] 

["test111", "111", index: 20, input: "now test001 test002 test111"] 

*/ 

/*var test="now test001 test002 test111"; 

var test1="now test001 test002 test111"; 

console.log(reg.exec(test)) 

console.log(reg.exec(test1)) lastIndex 的值已经改变 */ 

/*重要事项：如果在一个字符串中完成了一次模式匹配之后要开始检索新的字符串，就必须手动地把 lastIndex 属性重置为 0。 

提示： 

无论是否是全局模式，exec() 都会把完整的细节添加到它返回的数组中。 

对比match ，在非全局匹配模式下，返回第一个匹配的详细信息； 

    testStr.match(/test/); 

    result:["test", index: 4, input: "now test001 test002 test111"] 

在全局匹配模式下，返回一个大致信息的数组 

    testStr.match(/test/g); 

    result:["test", "test", "test"] 

因此可以这么说，在循环中反复地调用 exec() 方法是唯一一种获得全局模式的完整模式匹配信息的方法。 

# exec 方法 

var testStr = "now test001 test002 test111"; 

        var reg  = /test(\d+)/ig; 

        var arr = ""; 

        while(arr = reg.exec(testStr)) { 

            console.log(arr); 

        } 

["test001", "001", index: 4, input: "now test001 test002 test111"] 

["test002", "002", index: 12, input: "now test001 test002 test111"] 

["test111", "111", index: 20, input: "now test001 test002 test111"] 

reg.lastIndex 

var objStr="我的手机号13522222222，他的手机号13288888888，她的手机号码13699999999"; 

var reg=/13\d\d{8}/g; 

while(arr = reg.exec(objStr)){ 

    console.log(arr) 

    console.log(reg.lastIn* gfgfxgxkxfmkmcfldex); 

} 

# replace方法 

replace 使用回调函数，应该有返回值，才会将匹配的值替换掉； 

var str = "adajaasfjjjbkkdj"; 

var result= str.replace(/(.).*(\1)/g, function ($0, $1) { 

    console.log($0) 

    $0 = $1 + $0.substring(1).replace(new RegExp($1, 'g'), ''); 

    return $0; 

}); 

替换敏感词 

oTxt2.value = str.replace(/中国/g,function(str){ 

    var str=str; 

    var temp=''; 

    for(var i=0;i<str.length;i++){ 

        temp = temp+'*'; 

    } 

    return temp; 

}) 



# 正则实例



我们首先提出方案1，并分步做如下规则定义：

1.1.1 地址码规则：

* 地址码长6位
* 以数字1-9开头
* 后5位为0-9的数字

根据以上规则，写出地址码的正则表达式： /^[1-9]\d{5}/

1.1.2 年份码规则：

* 年份码长4位
* 以数字18，19或20开头
* 剩余两位为0-9的数字

根据以上规则，写出年份码的正则表达式： /(18|19|20)\d{2}/。如果不需要18开头的年份，可以去掉18。

1.1.3 月份码规则：

* 月份码长2位
* 第一位数字为0，第二位数字为1-9
* 或者第一位数字为1，第二位数字为0-2

根据以上规则，写出月份码的正则表达式： /((0[1-9])|(1[0-2]))/。

1.1.4 日期码规则：

* 日期码长2位
* 第一位数字为0-2，第二位数字为1-9
* 或者是10，20，30，31

根据以上规则，写出日期码的正则表达式 ： /(([0-2][1-9])|10|20|30|31)/。

1.1.5 顺序码规则：

根据以上规则，写出顺序码的正则表达式 ： /\d{3}/。

1.1.6 校验码规则：

根据以上规则，写出校验码的正则表达式 ： /[0-9Xx]/。

### 1.2 方案1正则表达式
综合以上6条规则，给出完整的正则表达式及测试程序如下：

1. var p =/^[1-9]\d{5}(18|19|20)\d{2}((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/; 
2. //输出 true
3. console.log(p.test("11010519491231002X"));
4. //输出 false 不能以0开头
5. console.log(p.test("01010519491231002X"));
6. //输出 false 年份不能以17开头
7. console.log(p.test("11010517491231002X"));
8. //输出 false 月份不能为13
9. console.log(p.test("11010519491331002X"));
10. //输出 false 日期不能为32
11. console.log(p.test("11010519491232002X"));
12. //输出 false 不能以a结尾
13. console.log(p.test("11010519491232002a"));
### 1.3 方案1分析
方案1只是做了基本的格式判定，存在三个主要的不足：

* 地址码判定不够精确。例：我国并不存在16，26开头的地区，却可通过验证
* 日期判定不够精确。例:19490231也可通过验证，而2月并不存在31日
* 校验码是由17位本体码计算得出，方案1并未校验此码
## 方案2 （全面）
根据方案1的不足，引入方案2进而改进方案1的不足。

### 2.1 省级地址码校验
华北：北京11，天津12，河北13，山西14，内蒙古15

东北： 辽宁21，吉林22，黑龙江23

华东： 上海31，江苏32，浙江33，安徽34，福建35，江西36，山东37

华中： 河南41，湖北42，湖南43

华南： 广东44，广西45，海南46

西南： 四川51，贵州52，云南53，西藏54，重庆50

西北： 陕西61，甘肃62，青海63，宁夏64，新疆65

特别：台湾71，香港81，澳门82

根据上述地址码做身份证号码的前两位校验，进一步的提高准确率。当前的地址码以2013版的行政区划代码【GB/T2260】为标准。由于区划代码的历史演变，使得地址码后四位校验变得不太可能。以三胖的身份证号为例，本人号码是2321开头，而当前行政区划代码表中并无此代码。因此本文只做前两位省级地址码的校验。

也有说法表述91开头是外国人取得中国身份证号码的前两位编码，但本人并未得到证实。如有持91开头身份证或认识马布里的，请帮忙确认相关信息。

根据以上分析，给出省级地址码校验及测试程序如下：

1. var checkProv =function(val){ 
2.    var pattern =/^[1-9][0-9]/; 
3.    var provs ={11:"北京",12:"天津",13:"河北",14:"山西",15:"内蒙古",21:"辽宁",22:"吉林",23:"黑龙江 ",31:"上海",32:"江苏",33:"浙江",34:"安徽",35:"福建",36:"江西",37:"山东",41:"河南",42:"湖北 ",43:"湖南",44:"广东",45:"广西",46:"海南",50:"重庆",51:"四川",52:"贵州",53:"云南",54:"西藏 ",61:"陕西",62:"甘肃",63:"青海",64:"宁夏",65:"新疆",71:"台湾",81:"香港",82:"澳门"}; 
4.    if(pattern.test(val)){
5.        if(provs[val]){
6.            returntrue;
7.        }
8.    }
9.    returnfalse;
10. }
11. //输出 true，37是山东
12. console.log(checkProv(37));
13. //输出 false，16不存在
14. console.log(checkProv(16));
### 2.2 出生日期码校验
出生日期码的校验不做解释，直接给出如下函数及测试程序：

1. var checkDate =function(val){ 
2.    var pattern =/^(18|19|20)\d{2}((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31)$/; 
3.    if(pattern.test(val)){
4.        var year = val.substring(0,4); 
5.        var month = val.substring(4,6); 
6.        var date = val.substring(6,8); 
7.        var date2 =newDate(year+"-"+month+"-"+date); 
8.        if(date2 && date2.getMonth()==(parseInt(month)-1)){ 
9.            returntrue;
10.        }
11.    }
12.    returnfalse;
13. }
14. //输出 true
15. console.log(checkDate("20180212"));
16. //输出 false 2月没有31日
17. console.log(checkDate("20180231"));
### 2.3 校验码校验
校验码的计算略复杂，先给出如下公式：

![图片](https://uploader.shimo.im/f/tOyAVbcu1awuXhde.jpeg!thumbnail)

其中 ai 表示身份证本体码的第 i 位值，而 Wi 表示第 i 位的加权因子值。

加权因子表 【表1】：

| i   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   |
|:----|:----|:----|:----|:----|:----|:----|:----|:----|
| Wi   | 7   | 9   | 10   | 5   | 8   | 4   | 2   | 1   |
| 9   | 10   | 11   | 12   | 13   | 14   | 15   | 16   | 17   |
| 6   | 3   | 7   | 9   | 10   | 5   | 8   | 4   | 2   |

X与校验码换算表 【表2】

| X   | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10   |
|:----|:----|:----|:----|:----|:----|:----|:----|:----|:----|:----|:----|
| a18   | 1   | 0   | X   | 9   | 8   | 7   | 6   | 5   | 4   | 3   | 2   |

算法过程：

* 根据身份证主体码（前17位）分别与对应的加权因子（表1）计算乘积再求和，根据所得结果与11取模得到X值。
* 根据 X 值查询表2，得出a18即校验码值。

校验码计算程序及测试见如下代码：

var checkCode =function(val){ 

var p =/^[1-9]\d{5}(18|19|20)\d{2}((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/; 

var factor =[7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2]; 

var parity =[1,0,'X',9,8,7,6,5,4,3,2]; 

var code = val.substring(17); 

if(p.test(val)){

var sum =0; 

for(var i=0;i<17;i++){ 

sum += val[i]*factor[i]; 

}

if(parity[sum %11]== code.toUpperCase()){ 

returntrue;

}

}

returnfalse;

}

// 输出 true， 校验码相符

console.log(checkCode("11010519491231002X"));

// 输出 false， 校验码不符

console.log(checkCode("110105194912310021"));

### 2.4 方案2整体代码
var checkID =function(val){ 

if(checkCode(val)){

var date = val.substring(6,14); 

if(checkDate(date)){

if(checkProv(val.substring(0,2))){

returntrue;

}

}

}

returnfalse;

}

//输出 true

console.log(checkID("11010519491231002X"));

//输出 false，校验码不符

console.log(checkID("110105194912310021"));

//输出 false，日期码不符

console.log(checkID("110105194902310026"));

//输出 false，地区码不符

console.log(checkID("160105194912310029"));

以上为三胖对身份证号码验证的理解和分析，如有不足请大家予以指正


去除字符串中相邻重复字符

'fdafffffffdaaklfjklja'.replace(/(\w)\1+/g,'$1’)  

非负整数

/^([1-9]\d*|0)$/

两位小数的数字

/^([1-9]\d*)?\d(\.\d{1,2})?$/       或者  /^0{1}(\.\d{1,2})?$|^[1-9]\d*(\.[0-9]{1,2})?$/

去除两边空白  

 /^\s+|\s+$/g

0-100 的数字  

 /^100$|^(\d|[1-9]\d)$/

必须有字母和数字  并且只能有数字字母下划线组成

/^((?=.*[0-9].*)(?=.*[A-Za-z].*))[_0-9A-Za-z]{8,20}$/


**1 用户名正则**

//用户名正则，4到16位（字母，数字，下划线，减号）

var uPattern = /^[a-zA-Z0-9_-]{4,16}$/;

//输出 true

console.log(uPattern.test("iFat3"));

**2 密码强度正则**

//密码强度正则，最少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符

var pPattern = /^.*(?=.{6,})(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&*? ]).*$/;

//输出 true

console.log("=="+pPattern.test("iFat3#"));

**3 整数正则**

//正整数正则

var posPattern = /^\d+$/;

//负整数正则

var negPattern = /^-\d+$/;

//整数正则

var intPattern = /^-?\d+$/;

//输出 true

console.log(posPattern.test("42"));

//输出 true

console.log(negPattern.test("-42"));

//输出 true

console.log(intPattern.test("-42"));

**4 数字正则** 

可以是整数也可以是浮点数

//正数正则

var posPattern = /^\d*\.?\d+$/;

//负数正则

var negPattern = /^-\d*\.?\d+$/;

//数字正则

var numPattern = /^-?\d*\.?\d+$/;

console.log(posPattern.test("42.2"));

console.log(negPattern.test("-42.2"));

console.log(numPattern.test("-42.2"));

**5 Email正则**

//Email正则

var ePattern = /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/;

//输出 true

console.log(ePattern.test("[65974040@qq.com](mailto:65974040@qq.com)"));

**6 手机号码正则**

//手机号正则

var mPattern = /^((13[0-9])|(14[5|7])|(15([0-3]|[5-9]))|(18[0,5-9]))\d{8}$/;

//输出 true

console.log(mPattern.test("18600000000"));

**7 身份证号正则**

//身份证号（18位）正则

var cP = /^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$/;

//输出 true

console.log(cP.test("11010519880605371X"));

**8 URL正则**

//URL正则

var urlP= /^((https?|ftp|file):\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/;

//输出 true

console.log(urlP.test("[http://42du.cn"));](http://42du.cn/)

**9 IPv4地址正则**

//ipv4地址正则

var ipP = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;

//输出 true

console.log(ipP.test("115.28.47.26"));

**10 十六进制颜色正则**

//RGB Hex颜色正则

var cPattern = /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/;

//输出 true

console.log(cPattern.test("#b8b8b8"));

**11 日期正则**

//日期正则，简单判定,未做月份及日期的判定

var dP1 = /^\d{4}(\-)\d{1,2}\1\d{1,2}$/;

//输出 true

console.log(dP1.test("2017-05-11"));

//输出 true

console.log(dP1.test("2017-15-11"));

//日期正则，复杂判定

var dP2 = /^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$/;

//输出 true

console.log(dP2.test("2017-02-11"));

//输出 false

console.log(dP2.test("2017-15-11"));

//输出 false

console.log(dP2.test("2017-02-29"));

**12 QQ号码正则**

//QQ号正则，5至11位

var qqPattern = /^[1-9][0-9]{4,10}$/;

//输出 true

console.log(qqPattern.test("65974040"));

**13 微信号正则**

//微信号正则，6至20位，以字母开头，字母，数字，减号，下划线

var wxPattern = /^[a-zA-Z]([-_a-zA-Z0-9]{5,19})+$/;

//输出 true

console.log(wxPattern.test("RuilongMao"));

**14 车牌号正则**

//车牌号正则

var cPattern = /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/;

//输出 true

console.log(cPattern.test("京K39006"));

**15 包含中文正则**

//包含中文正则

var cnPattern = /[\u4E00-\u9FA5]/;

//输出 true

console.log(cnPattern.test("42度"));


**一、校验数字的表达式**

1. 零和非零开头的数字：^(0|[1-9][0-9]*)$
2. 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$
3. 带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$
4. 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$
5. 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$
6. 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$
7. 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$
8. 非零的负整数：^\-[1-9][]0-9"*$ 或 ^-[1-9]\d*$
9. 非负整数：^\d+$ 或 ^[1-9]\d*|0$
10. 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$
11. 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$
12. 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$
13. 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$
14. 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$
15. 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$

**二、校验字符的表达式**

1. 汉字：^[\u4e00-\u9fa5]{0,}$
2. 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$
3. 长度为3-20的所有字符：^.{3,20}$
4. 由26个英文字母组成的字符串：^[A-Za-z]+$
5. 由26个大写英文字母组成的字符串：^[A-Z]+$
6. 由26个小写英文字母组成的字符串：^[a-z]+$
7. 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$
8. 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$
9. 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$
10. 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$
11. 可以输入含有^%&',;=?$\"等字符：[^%&',;=?$\x22]+ 12 禁止输入含有~的字符：[^~\x22]+
12. 12 禁止输入含有~的字符：[^~\x22]+

**三、特殊需求表达式**

1. Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$
2. 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?
3. InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$
4. 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$
5. 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$
6. 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7}
7. 身份证号(15位、18位数字)：^\d{15}|\d{18}$
8. 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$
9. 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
10. 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$
11. 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$
12. 日期格式：^\d{4}-\d{1,2}-\d{1,2}
13. 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$
14. 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$
15. 钱的输入格式：
16. 1.有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$
17. 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$
18. 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$
19. 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$
20. 5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$
21. 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$
22. 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$

23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$

1. 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里
2. xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$
3. 中文字符的正则表达式：[\u4e00-\u9fa5]
4. 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))
5. 空白行的正则表达式：\n\s*\r (可以用来删除空白行)
6. HTML标记的正则表达式：<(\S*?)[^>]*>.*?</\1>|<.*? /> (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)
7. 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)
8. 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)
9. 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)
10. IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)
11. IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))

日期：((^((1[8-9]\d{2})|([2-9]\d{3}))([-\/\._])(10|12|0?[13578])([-\/\._])(3[01]|[12][0-9]|0?[1-9])$)|(^((1[8-9]\d{2})|([2-9]\d{3}))([-\/\._])(11|0?[469])([-\/\._])(30|[12][0-9]|0?[1-9])$)|(^((1[8-9]\d{2})|([2-9]\d{3}))([-\/\._])(0?2)([-\/\._])(2[0-8]|1[0-9]|0?[1-9])$)|(^([2468][048]00)([-\/\._])(0?2)([-\/\._])(29)$)|(^([3579][26]00)([-\/\._])(0?2)([-\/\._])(29)$)|(^( [1] [89][0][48])([-\/\._])(0?2)([-\/\._])(29)$)|(^([2-9][0-9][0][48])([-\/\._])(0?2)([-\/\._])(29)$)|(^( [1] [89][2468][048])([-\/\._])(0?2)([-\/\._])(29)$)|(^([2-9][0-9][2468][048])([-\/\._])(0?2)([-\/\._])(29)$)|(^( [1] [89][13579][26])([-\/\._])(0?2)([-\/\._])(29)$)|(^([2-9][0-9][13579][26])([-\/\._])(0?2)([-\/\._])(29)$))

 

  

使用[\n ]  不用\s  直接打一个空格也可以把 空格替换掉 

*//正浮点数*

/^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$/;

*//负浮点数*

/^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$/;

*//浮点数*

/^(-?\d+)(\.\d+)?$/;

*//email地址*

/^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/;

*//url地址*

/^[a-zA-z]+://(\w+(-\w+)*)(\.(\w+(-\w+)*))*(\?\S*)?$/;

或：^http:\/\/[A-Za-z0-9]+\.[A-Za-z0-9]+[\/=\?%\-&_~`@[\]\':+!]*([^<>\"\"])*$

*//年/月/日（年-月-日、年.月.日）*

/^(19|20)\d\d[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$/;

*//匹配中文字符*

/[\u4e00-\u9fa5]/;

*//匹配帐号是否合法(字母开头，允许5-10字节，允许字母数字下划线)*

/^[a-zA-Z][a-zA-Z0-9_]{4,9}$/;

*//匹配空白行的正则表达式*

/\n\s*\r/;

*//匹配中国邮政编码*

/[1-9]\d{5}(?!\d)/;

*//匹配身份证*

/\d{15}|\d{18}/;

*//匹配国内电话号码*

/(\d{3}-|\d{4}-)?(\d{8}|\d{7})?/;

   *//匹配IP地址* 

/((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)/;

*//匹配首尾空白字符的正则表达式*

/^\s*|\s*$/;

*//匹配HTML标记的正则表达式*

< (\S*?)[^>]*>.*?|< .*? />; 

   *//sql 语句* 

^(select|drop|**delete**|create|update|insert).*$

*//提取信息中的网络链接*

(h|H)(r|R)(e|E)(f|F) *= *(**'|")?(****\w****|****\\****|****\/****|****\.****)+('**|**"| *|>)?**

*//提取信息中的邮件地址*

\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*

*//提取信息中的图片链接*

(s|S)(r|R)(c|C) *= *(**'|")?(****\w****|****\\****|****\/****|****\.****)+('**|**"| *|>)?**

*//提取信息中的 IP 地址*

(\d+)\.(\d+)\.(\d+)\.(\d+)

*//取信息中的中国手机号码*

(86)*0*13\d{9}

*//提取信息中的中国邮政编码*

[1-9]{1}(\d+){5}

*//提取信息中的浮点数（即小数）*

(-?\d*)\.?\d+

*//提取信息中的任何数字*

(-?\d*)(\.\d+)?

    *//电话区号* 

*   * ^0\d{2,3}$ 

*//腾讯 QQ 号*

^[1-9]*[1-9][0-9]*$

*//帐号（字母开头，允许 5-16 字节，允许字母数字下划线）*

^[a-zA-Z][a-zA-Z0-9_]{4,15}$

*//中文、英文、数字及下划线*

^[\u4e00-\u9fa5_a-zA-Z0-9]+$

1、匹配QQ号（**首位不为0/5-12位**）

 /^[1-9]\d{4,11}$/

2、匹配中文

/^[\u4e00-\u9fa5]$/    //中文ASCII码范围

3、匹配姓名可加空格,且2-20位字符

/^([\u4e00-\u9fa5]+\s*[\ue400-\u9fa5]*){2,20}$/

4、匹配行首行尾空格

/^[^\S]* | （\s）*$/ 

5、匹配邮箱

/^\w+@[a-z0-9]+(\.[a-z]+){1,3}$/

6、匹配网址(**http://**)

/^[a-zA-Z]+://[^\s]*$/

7、匹配邮编

/^[1-9]\d{5}$/

8、匹配身份证

/^[1-9]\d{14} | [1-9]\d{17} | [1-9]\d{16}x$/



9、匹配电话号码

/^1[3|4|5|7|8|9]\d{9}$/

10、匹配固定电话

/^(\d{3}-\d{8}) | (\d{4}-\d{7}) | \d{11}$/

11、匹配用户名（**只能输入1-20个以字母开头的字串,可以包含数字**）

/^([a-zA-Z]+[a-zA-Z0-9])*{1-20}$/

12、匹配密码（**只能输入8-20个字母、数字、下划线**）

/^(\w){8,20}$/



    /^[-]?\d+([.]?\d*)$/                  //数字 

    /^[-]?\d+$/                           //整数 

    /^[0-9a-zA-Z]{5,16}$/                 //用户名(区分大小写，5-16位) 

    /^[\u4e00-\u9fa5]+$/                  //中文 

    /^(\w){6,20}$/;                       //校验密码：只能输入6-20个字母、数字、下划线 

    //电话号码(手機號碼):像(010)88886666，022-22334455，029 1234-5678，010 3523922轉259，3523922。04-36018188/23051418 等 

    /^([(（]?0\d{1,6}[）) -]?)?(\d{5,30}|((\d{4}[ -]){1,7}\d{1,4}))([ -#(（轉转]?\d{1,6}[）)]?)?$/; 

    /^#?([a-f0-9]{6}|[a-f0-9]{3})$/       //十六进制值 

    /^([a-zA-Z\d_\.-]+)@([a-zA-Z\d]+\.)+[a-zA-Z\d]{2,6}$/                     //电子邮箱 

    /^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/          //URL 

    //下句是 IP 地址: 1.0.0.1 到 255.255.255.255,每段不能用“0”打头 

    /^([1-9]|([1-9]\d)|(1\d\d)|(2([0-4]\d|5[0-5])))\.(([\d]|([1-9]\d)|(1\d\d)|(2([0-4]\d|5[0-5])))\.){2}([1-9]|([1-9]\d)|(1\d\d)|(2([0-4]\d|5[0-5])))$/ 

    /^<([a-z]+)([^<]+)*(?:>(.*)<\/\1>|\s+\/>)$/           //HTML 标签 

     "str".replace(/(^\s*)|(\s*$)/g, ""); // 去除前后空格 

     //校验登录名：只能输入5-20个以字母开头、可带数字、“_”、“.”的字符串 

     function isRegisterUserName(s) { 

         var patrn = /^[a-zA-Z]{1}([a-zA-Z0-9]|[._]){4,19}$/; 

         return !!(patrn.exec(s));    //返回匹配数组,没有匹配时返回null;所以非两次以返回boolean值 

     } 

     //防止SQL注入，返回true表示通过验证，返回false表示验证不通过 

     function IsValid( oField ) { 

         re= /select|update|delete|exec|count|'|"|=|;|>|<|%/i; 

         $sMsg = "请您不要在参数中输入特殊字符和SQL关键字！"; 

         if ( re.test(oField.value) ) { 

              alert( $sMsg ); 

              return false; 

         } 

         return true; 

     } 

     // 日期检查 

     function strDateTime(str) 

     { 

        var r = str.match(/^(\d{1,4})(-|\/)?(\d{1,2})\2(\d{1,2})$/); // 注意里面的“\2”，表示要求与第2个捕获组“(-|\/)?”的值相同 

        if ( r == null ) return false; 

        var d = new Date(r[1], r[3]-1, r[4]); 

        return (d.getFullYear()==r[1] && (d.getMonth()+1)==r[3] && d.getDate()==r[4]); 

     } 





## 删除注释

删除 java 注释 /* */：

```javascript
/\*{1,2}[\s\S]*?\*/
```

删除 java 注释 //：  注意https://中的

```javascript
//[\s\S]*?\n  
```

删除xml注释：

```javascript
<!-[\s\S]*?-->
```

删除空白行：

```javascript
^\s*\n
```