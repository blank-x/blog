1. Number.prototype.toPrecision()  数值总共显示多少位数(包括小数点),即可以定义数值的精度     

# ES6 Number

```javascript
Number.isInteger(Infinity)// false

Number.isNaN("NaN")// false

Number.EPSILON

Math.acosh(3)// 1.762747174039086

Math.hypot(3,4)// 5

Math.imul(Math.pow(2,32)-1,Math.pow(2,32)-2)// 2

// 取整 Math.trunc (如果不是数字，先调用number)

Math.trunc('123.456') // 123

Math.trunc(4.9) // 4

Math.trunc(true) //1

Math.trunc(false) // 0

Math.trunc(null) // 0

**ES6添加了二进制和八进制数值的字面量定义方法：**

0b111110111===503 // true

0o767===503 // true

0x1d     // 16进制29
```

# 精度问题集锦

(0.1 * 10 + 0.2 * 10) / 10  => 0.3

1.005*100    =>100.49999999999999

2177.74*100 =>  217773.99999999997





方案一：把小数转化为字符串，拆分整数部分和小数部分分别计算，然后再把结果进行拼接;

方案二：先乘10的整数倍，然后再用toFixed进行四舍五入，这样能保证结果还是准确的，如：

(2177.74*100).toFixed(0); //217774

方案三：直接运算，然后再用toFixed（或者Math.round）进行四舍五入，用于对计算结果不是很精确的场景。





一是先升幂再降幂：

```
function add(num1, num2){ 

   let r1, r2, m; 
   r1 =(''+num1).split('.')[1].length; 
   r2 =(''+num2).split('.')[1].length; 
   m =Math.pow(10,Math.max(r1,r2)); 
   return(num1 * m + num2 * m)/ m; 
}

console.log(add(0.1,0.2));   //0.3 
console.log(add(0.15,0.2256));//0.3756
```

二是是使用内置的 toPrecision() 和 toFixed() 方法，注意，方法的返回值字符串。

```
function add(x, y){ 
   return x.toPrecision()+ y.toPrecision() 
}
console.log(add(0.1,0.2));  //"0.10.2"
```



# 浮点数的存储

首先要搞清楚 JavaScript 如何存储小数。和其它语言如 Java 和 Python 不同，JavaScript 中所有数字包括整数和小数都只有一种类型 — Number。它的实现遵循 IEEE 754 标准，使用 64 位固定长度来表示，也就是标准的 double 双精度浮点数。

这样的存储结构优点是可以归一化处理整数和小数，节省存储空间。

64位比特又可分为三个部分：

符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数

指数位E：中间的 11 位存储指数（exponent），用来表示次方数

尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零

![图片](https://uploader.shimo.im/f/HyxyFC6RmpUMYNdd.png!thumbnail)

实际数字就可以用以下公式来计算：

![图片](https://uploader.shimo.im/f/DwNEU8NZSJEPAZKV.png!thumbnail)

注意以上的公式遵循科学计数法的规范，在十进制是为0<M<10，到二进行就是0<M<2。也就是说整数部分只能是1，所以可以被舍去，只保留后面的小数部分。如 4.5 转换成二进制就是 100.1，科学计数法表示是 1.001*2^2，舍去1后 M = 001。E是一个无符号整数，因为长度是11位，取值范围是 0~2047。但是科学计数法中的指数是可以为负数的，所以再减去一个中间数 1023，[0,1022]表示为负，[1024,2047] 表示为正。如4.5 的指数E = 1025，尾数M为 001。

## 最终的公式

![图片](https://uploader.shimo.im/f/ir6UejxkVlUFWnfz.png!thumbnail)

所以 4.5 最终表示为（M=001、E=1025）：

![图片](https://tva1.sinaimg.cn/large/006tNbRwgy1ga7nsnoz5zj313i074dfy.jpg)

下面再以 0.1 例解释浮点误差的原因， 0.1 转成二进制表示为 0.0001100110011001100(1100循环)，1.100110011001100x2^-4，所以 E=-4+1023=1019；M 舍去首位的1，得到 100110011...。最终就是：

![图片](https://tva1.sinaimg.cn/large/006tNbRwgy1ga7nsl0q8tj312u06wwep.jpg)

转化成十进制后为 0.100000000000000005551115123126，因此就出现了浮点误差。

## 0.1+0.2=0.30000000000000004？

计算步骤为：

// 0.1 和 0.2 都转化成二进制后再进行运算

0.00011001100110011001100110011001100110011001100110011010 + 

0.0011001100110011001100110011001100110011001100110011010 = 

0.0100110011001100110011001100110011001100110011001100111

// 转成十进制正好是 0.30000000000000004

## 为什么 x=0.1 能得到 0.1？

恭喜你到了看山不是山的境界。因为 mantissa 固定长度是 52 位，再加上省略的一位，最多可以表示的数是 2^53=9007199254740992，对应科学计数尾数是 9.007199254740992，这也是 JS(十进制) 最多能表示的精度。它的长度是 16，所以可以使用 toPrecision(16) 来做精度运算，超过的精度会自动做凑整处理。于是就有：

0.10000000000000000555.toPrecision(16)

// 返回 0.1000000000000000，去掉末尾的零后正好为 0.1

// 但你看到的 `0.1` 实际上并不是 `0.1`。不信你可用更高的精度试试：

0.1.toPrecision(21) = 0.100000000000000005551 

## 大数危机

可能你已经隐约感觉到了，如果整数大于 9007199254740992 会出现什么情况呢？

由于 E 最大值是 1023，所以最大可以表示的整数是 2^1024 - 1，这就是能表示的最大整数。但你并不能这样计算这个数字，因为从 2^1024 开始就变成了 Infinity

> Math.pow(2, 1023) 

8.98846567431158e+307

> Math.pow(2, 1024) 

Infinity

那么对于 (2^53, 2^63) 之间的数会出现什么情况呢？

(2^53, 2^54) 之间的数会两个选一个，只能精确表示偶数  // 并且选泽哪一个没有规律

(2^54, 2^55) 之间的数会四个选一个，只能精确表示4个倍数

* ... 依次跳过更多2的倍数

我们常用的 (-2^53, 2^53) 只是所有数字中很小的一部分。



在淘宝早期的订单系统中把订单号当作数字处理，后来随意订单号暴增，已经超过了9007199254740992，最终的解法是把订单号改成字符串处理。

要想解决大数的问题你可以引用第三方库 bignumber.js，原理是把所有数字当作字符串，重新实现了计算逻辑，缺点是性能比原生的差很多。所以原生支持大数就很有必要了，现在 TC39 已经有一个 Stage 3 的提案 proposal bigint，大数问题有问彻底解决。

## toPrecision vs toFixed

toFixed 和 toPrecision 都能取整，解决计算过程中产生的精度问题

但是这两种方案没有直接使用整数来计算的效果好：



数据处理时，这两个函数很容易混淆。它们的共同点是把数字转成字符串供展示使用。注意在计算的中间过程不要使用，只用于最终结果。

不同点就需要注意一下：

toPrecision 是处理精度，精度是从左至右第一个不为0的数开始数起。  // 可以四舍五入 12.999.toPrecision(3)   "13.0"

toFixed 是小数点后指定位数取整，从小数点开始数起。  // 12.999.toFixed(2)  "13.00"

两者都能对多余数字做凑整处理，也有些人用 toFixed 来做四舍五入，但一定要知道它是有 Bug 的。

如：1.005.toFixed(2) 返回的是 1.00 而不是 1.01。

原因： 1.005 实际对应的数字是 1.00499999999999989，在四舍五入时全部被舍去！

解法：使用专业的四舍五入函数 Math.round() 来处理。但 Math.round(1.005 * 100) / 100 还是不行，因为 1.005 * 100 = 100.49999999999999。还需要把乘法和除法精度误差都解决后再使用 Math.round。

Math.round(1005*100/1000)/100



## 展示数据-解决

当你拿到 1.4000000000000001 这样的数据要展示时，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示，如下：

parseFloat(1.4000000000000001.toPrecision(12)) === 1.4  // True 

封装成方法就是：

```javascript
function strip(num, precision = 12) { 
	 return +parseFloat(num.toPrecision(precision)); 
}
```

为什么选择 12 做为默认精度？这是一个经验的选择，一般选12就能解决掉大部分0001和0009问题，而且大部分情况下也够用了，如果你需要更精确可以调高。

## 数据运算类-解决

对于运算类操作，如 +-*/，就不能使用 toPrecision 了。正确的做法是把小数转成整数后再运算。以加法为例：

```
function add(num1, num2) { 
     const num1Digits = (num1.toString().split('.')[1] || '').length; 
     const num2Digits = (num2.toString().split('.')[1] || '').length; 
     const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits)); 
     return (num1 * baseNum + num2 * baseNum) / baseNum; 
}
```

以上方法能适用于大部分场景。遇到科学计数法如 2.3e+1（当数字精度大于21时，数字会强制转为科学计数法形式显示）时还需要特别处理一下。

能读到这里，说明你非常有耐心，那我就放个福利吧。遇到浮点数误差问题时可以直接使用[https://github.com/dt-fe/number-precision](https://github.com/dt-fe/number-precision)

完美支持浮点数的加减乘除、四舍五入等运算。非常小只有1K，远小于绝大多数同类库（如Math.js、BigDecimal.js），100%测试全覆盖，代码可读性强，不妨在你的应用里用起来！


## 
# 题目

Number.MAX_VALUE + 1 == Number.MAX_VALUE;

Number.MAX_VALUE + 2 == Number.MAX_VALUE;

...

Number.MAX_VALUE + x == Number.MAX_VALUE;

Number.MAX_VALUE + x + 1 == Infinity;

...

Number.MAX_VALUE + Number.MAX_VALUE == Infinity;

// 问题：

// 1. x 的值是什么？

// 2. Infinity - Number.MAX_VALUE == x + 1; 是 true 还是 false ?

如果考虑浮点数的精度问题，那么 x 无解。推理很简单，根据 Number.MAX_VALUE + x == Number.MAX_VALUE 和 Number.MAX_VALUE + x + 1 == Infinity 可以推得 Number.MAX_VALUE + 1 == Infinity ，显然这是不成立的，所以 x 无解。 

但是显然玉伯这里不希望我们考虑精度损失问题。

我们先来看 Number.MAX_VALUE，在前面的文章中我们已经给出了它的值为： 

1 * (Math.pow(2, 53) - 1) * Math.pow(2, 971) = 1.7976931348623157e+308

我们用二进制可以这样表示：

1 1 1 1 .. (53个1) .. 1 1 1 0 0 0 0 .. (971个0) .. 0 0 0 0

53 个 1 的 第一位是**隐藏位**（hidden bit），后 52 位即为 m，而 971 个 0 即代表了指数 e（当然实际存储中 e 并不是这样表示的）。 

接着我们把这个数加上 1，如果我们把这个数用二进制表示，可以表示为：

1 1 1 1 .. 53个1 .. 1 1 1 0 0 0 0 .. 970个0 .. 0 0 0 1

如果我们把该数用 IEEE 754 双精度浮点型表示出来，m 并不会有什么变化，因为 **m 控制了这个数的精度**，m 只能有 52 位，而加上的 1 对于这个大数字来说实在太微不足道！结果还是 Number.MAX_VALUE。 

那么加上个什么数之后会引起质变呢？答案是 2 ^ 970，因为加上这个数之后，我们用二进制表示：

1 1 1 1 .. 53个1 .. 1 1 1 1 0 0 0 .. 970个0 .. 0 0 0 0

而该数用 IEEE 754 双精度浮点型表示时，由于 第 52 位 和 53 位同时为 1，所以会进位（Ties To Even），于是这个数变为了 Infinity。

那么 Number.MAX_VALUE + x == Number.MAX_VALUE 的解集似乎就呼之欲出了，x 的范围是 [0, 2 ^ 970)，即[0, 2 ^ 970 - 1]（如果考虑精度丢失的话，这个解集会是 [0, 2 ^ 970 - 2 ^ (970 - 53)]）。 

于是问题演变成 Number.MAX_VALUE + y == Infinity，而 y 的取值是 [1, 2 ^ 970]，求 y。 

前面已经说了当 y 为 2 ^ 970 时才会发生质变，所以可求得 x 为 2 ^ (970 - 1)。如果把 Number.MAX_VALUE 用 0xfffffffffffff8000... 来表示的话，那么这个数可以用 0x0000000000003ffff... 来表示。 

问题 2 就很简单了，因为 Infinity - Number.MAX_VALUE 还是等于 Infinity，而 x + 1 还是等于 x，显然不会达到 Infinity。



Number.MAX_VALUE.toString(16) = ”

fffffffffffff800000000000000000000000000000

00000000000000000000000000000000000000

00000000000000000000000000000000000000

00000000000000000000000000000000000000

00000000000000000000000000000000000000

00000000000000000000000000000000000000

00000000000000000000000″

前面有 13 个 f, 二进制就是 52 个 1

还有一个 8, 二进制是 1000

也就是说，前面 53 位都是 1

这样，当 Number.MAX_VALUE + 1 时，1 替代最后一个 0，但 IEEE 754 双精度浮点数的 m 最大为 53（含隐藏位），因此添加的 1 在存储时会被舍弃掉，所以：

Number.MAX_VALUE + 1 == Number.MAX_VALUE

同理类推，当 8（1000） 变成 b（1011），b 后面的位取最大值时，依旧有：

0xfffffffffffffbfffffffffffffffffffffffffffffffffffff

fffffffffffffffffffffffffffffffffffffffffffffffffffffff

fffffffffffffffffffffffffffffffffffffffffffffffffffffff

fffffffffffffffffffffffffffffffffffffffffffffffffffffff

ffffffffffffffffffffffffffffffffffffffff == Number.MAX_VALUE

进一步，当 再增 1, b 变成 c 时，将发生质变：

0xfffffffffffffc00000000000000000000000000

000000000000000000000000000000000000

000000000000000000000000000000000000

000000000000000000000000000000000000

000000000000000000000000000000000000

000000000000000000000000000000000000

000000000000000000000000000000000000 == Infinity

这是因为前面将有 54 个连续的 1, 在存储时，exponent 将由971 变成 972, 超出了 IEEE 754 双精度浮点数存储格式中 e 的最大值，因此质变为 Infinity 了。

这样，题目中 x 的值就很容易得到了：

x = 0xfffffffffffffbffff… – 0xfffffffffffff80000…

= 0x00000000000003ffff…

注意这个数在IEEE 754 双精度浮点数格式下无法精确存储。

## 两个有趣的结论：

1. Number.MAX_VALUE 不是一个数，而是一个区间 [0xfffffffffffff80000…, 0xfffffffffffffc0000…)

2. Infinity 指的是，所有大于等于 0xfffffffffffffc0000… 的数。

## 几条有趣的规律：

* Javascript 能精确保存的最大整数为 2 ^ 53，即为 9007199254740992，当 x 大于等于 9007199254740992时，x === x + 1。Javascript 能精确表示的整数的范围是 [- 2 ^ 53, 2 ^ 53]
* Number.MAX_VALUE 不是一个数，而是一个区间 [0xfffffffffffff80000…, 0xfffffffffffffc0000…) 任何大于等于 9007199254740992 的数都是一个区间，没有丢失精度的数只是区间中的一个数。"我不是一个数，是一堆数⋯⋯"
* Infinity 指的是，所有大于等于 0xfffffffffffffc0000… 的数



Javascript 能精确表示的数的范围是 (-2^53, 2^53)，而不是文中所说的 [-2^53, 2^53]。这里能精确表示的意思是，只有一个数能对应该数。

为什么 2^53 不能精确表示？ 2^53=9007199254740992，而在 Javascript 中 9007199254740993 也表示成 9007199254740992，所以如果在运算中出现 9007199254740992，是无法确定原数的（两种可能）。

我们可以用 Number.MIN_SAFE_INTEGER 和 Number.MAX_SAFE_INTEGER 来表示最小以及最大能精确表示的数，并能用 Number.isSafeInteger() 来检查一个数是否能精确表示。 



(s) * (m) * (2^e)

s 是符号位，表示正负。m 是尾数，有 **52** bits。e 是指数，有 **11** bits，e 的范围是 **[-1074, 971]**，这样其实很容易推出为： 

##  Javascript 能表示的最大数

1 * (Math.pow(2, 53) - 1) * Math.pow(2, 971) = 1.7976931348623157e+308

而这个数也就是 Number.MAX_VALUE 的值。 

同理可推得 Number.MIN_VALUE 的值： 

1 * 1 * Math.pow(2, -1074) = 5e-324



需要注意的是，Number.MIN_VALUE 表示的是**最小的比零大的数**，而不是最小的数，最小的数很显然是 -Number.MAX_VALUE。 



# 小数转成二进制



① 整数部分：除2取余数，若商不为0则继续对它除2，当商为0时则将所有余数逆序排列；

② 小数部分：乘2取整数部分，若小数不为0则继续乘2，直至小数部分为0将取出的整数位正序排列。（若小数部分无法为零，根据有效位数要求取得相应数值，位数后一位0舍1入进行取舍）

利用上述方法，我们尝试一下将0.1转成二进制：

0.1 * 2 = 0.2 - - - - - - - - - - 取0

0.2 * 2 = 0.4 - - - - - - - - - - 取0

0.4 * 2 = 0.8 - - - - - - - - - - 取0

0.8 * 2 = 1.6 - - - - - - - - - - 取1

0.6 * 2 = 1.2 - - - - - - - - - - 取1

0.2 * 2 = 0.4 - - - - - - - - - - 取0

......

算到这就会发现小数部分再怎么继续乘都不会等于0，所以二进制是没办法精确表示0.1的。

那么0.1的二进制表示是：0.000110011......0011...... (0011无限循环)

而0.2的二进制表示则是：0.00110011......0011...... (0011无限循环)



当然计算机并不能表示无限小数，毕竟只有有限的资源，于是我们得把它们用来表示： 



e = -4; m = 1.1001100110011001100110011001100110011001100110011010 (52位)

e = -3; m = 1.1001100110011001100110011001100110011001100110011010 (52位)

当然，真实的计算机存储中 m 并不会是一个小数，而是上面的小数点后的 52 bits，小数点前的 1 为**隐藏位**。

这里又出现一个问题，虽然我们已经明确 m 只能有 52 位（小数点后)，但是如果第 53 位是 1，是该进位还是不进位？

关于默认的舍入规则，简单的说，如果 1.101 要保留一位小数，可能的值是 1.1 和 1.2，那么先看 1.101 和 1.1 或者 1.2 哪个值更接近，毫无疑问是 1.1，于是答案是 1.1。那么如果要保留两位小数呢？很显然要么是 1.10 要么是 1.11，而且又一样近，这时就要看这两个数哪个是偶数（末位是偶数），保留偶数为答案。综上，如果第 52 bit 和 53 bit 都是 1，那么是要进位的。

另外，相加时如果指数不一致，需要对齐，一般情况下是向右移，因为最右边的即使溢出了，损失的精度远远小于左边溢出。

接下去就不难了：



e = -4; m = 1.1001100110011001100110011001100110011001100110011010 (52位)

e = -3; m = 1.1001100110011001100110011001100110011001100110011010 (52位)

---------------------------------------------------------------------------

e = -3; m = 0.1100110011001100110011001100110011001100110011001101

e = -3; m = 1.1001100110011001100110011001100110011001100110011010

---------------------------------------------------------------------------

e = -3; m = 10.0110011001100110011001100110011001100110011001100111

---------------------------------------------------------------------------

e = -2; m = 1.0011001100110011001100110011001100110011001100110100(52位)

---------------------------------------------------------------------------

= 0.010011001100110011001100110011001100110011001100110100

= 0.30000000000000004(十进制)

而 9007199254740992 + 1 = 9007199254740992 的推理过程大同小异。 

9007199254740992 其实就是 2 ^ 53。



e = 0; m = 100000000000000000000000000000000000000000000000000000 (53个0)

e = 0; m = 1

---------------------------------------------------------------------------

e = 0; m = 100000000000000000000000000000000000000000000000000001

因为 m 只能有 52 位，而上面相加两数相加后 m 有 53 位（已经除去首位隐藏位），又因为 的偶数原则，所以将 53 bit 的 1 舍去，所以大小跟 2 ^ 52 并没有变化，试想下，如果是 + 2，那么结果就不一样了。（ps：其实 2^53 在计算机存储中的 m 只能有 52 位，即只有 52 个 0） 

事实上，当结果大于 Math.pow(2, 53) 时，会出现精度丢失，导致最终结果存在偏差，而当结果大于 Number.MAX_VALUE，直接返回 Infinity。



之前类似如此的精度缺失问题，我都会推荐先将其乘以 10 的倍数，化为整数的方式：



Math.pow(2,53) 竟然与 Math.pow(2,53)+1 相等！这是因为 Math.pow(2, 53) + 1 已经超过了尾数的精度限制(53 bit)，在这个例子中 Math.pow(2,53) 和 Math.pow(2,53)+1 对应了同一个双精度浮点数。所以 Math.pow(2,53) 就不是安全数了。

# Number.MAX_SAFE_INTEGER

最大的安全数为 Math.pow(2,53)-1，即 9007199254740991。

0.1 + 1 - 1  => 0.10000000000000009

0.1 * 0.2  => 0.020000000000000004

Math.pow(2, 53)   // 9007199254740992

Math.pow(2, 53) + 1  // 9007199254740992

Math.pow(2, 53) + 3  //9007199254740996



绝对值的最大安全值 

从上面可以看出，8 个字节能存储的最大数值是 Number.MAX_VALUE 的值，也就是 ~=Math.pow(2,1024)-1。 

但这个数值并不安全：从 1 到 Number.MAX_VALUE 中间的数字并不连续，而是离散的。 

比如： Number.MAX_VALUE-1, Number.MAX_VALUE-2 等数值都无法用公式得出，就存储不了。 

所以这里引出了最大安全值 Number.MAX_SAFE_INTEGER，也就是从 1 到 Number.MAX_SAFE_INTEGER 中间的数字都是连续的，处在这个范围内的数值计算都是安全的。 

当 f=11...11,e=1075（中间省略 48 个 1）时，取得这个值 111...11（中间省略 48 个 1），即 Math.pow(2,53)-1。 

大于 Number.MAX_SAFE_INTEGER：Math.pow(2,53)-1 的数值都是离散的。 

比如： Math.pow(2,53)+1, Math.pow(2,53)+3 不能用公式得出，无法存储在内存中。 

所以才会有文章开头的现象：Math.pow(2, 53)  9007199254740992

null


1. null

2. > Math.pow(2, 53) + 1 
3. 9007199254740992

null


1. null

2. > Math.pow(2, 53) + 3 
3. 9007199254740996

因为 Math.pow(2,53)+1 不能用公式得出，就无法存储在内存中，所以只有取最靠近这个数的、能够用公式得出的其他数， Math.pow(2,53)，然后存储在内存中，这就是失真，即不安全。 

 为什么 Math.pow(2,53)+1 结果是 Math.pow(2,53) 

 比这个数小的、最靠近的数：Math.pow(2, 53) 

比这个数小的、最靠近的数：Math.pow(2, 53) 

(f = 0000000000000000000000000000000000000000000000000000, e = 1076) 

比这个数大的、最靠近的数：Math.pow(2, 53) + 2 


(f = 0000000000000000000000000000000000000000000000000001, e = 1076) 

取第一个数： Math.pow(2,53)。 

所以：Math.pow(2, 53) + 1 === Math.pow(2, 53)  true

为了安全的比较两个小数，引入 Number.EPSILON[Math.pow(2,-52)] 来比较浮点数。 

Math.abs(0.1 + 0.2 - 0.3) < Number.EPSILON  // true

# 常量

## Number.EPSILON 

表示 1 与 Number 可表示的大于 1 的最小的浮点数之间的差值。

Math.pow(2, -52)

用于浮点数之间安全的比较大小。

## Number.MAXSAFEINTEGER 

绝对值的最大安全值。

Math.pow(2, 53) - 1 

## Number.MAX_VALUE 

js 所能表示的最大数值（8 个字节能存储的最大数值）。 

~= Math.pow(2, 1024) - 1 

## Number.MINSAFEINTEGER 

最小安全值（包括符号）。

Math.pow(2, 53) - 1)

## Number.MIN_VALUE 

js 所能表示的最小数值（绝对值）。 

Math.pow(2, -1074)

## Number.NEGATIVE_INFINITY 

负无穷大。

-Infinity

## Number.POSITIVE_INFINITY 

正无穷大。

+Infinity

## Number.NaN 

非数字。



# 疑惑

Math.pow(2, 53) + 1 === Math.pow(2, 53)  // true

Math.pow(2, 53) +3 === Math.pow(2, 53)+2 // false  为什么

答案：关于默认的舍入规则，引入精度问题，离那个数近就用那个数，如果又一样近，这时就要看这两个数哪个是偶数（末位是偶数），保留偶数为答案。下图假如精度为五位

| Math.pow(2, 53)   | 实际值           | 二进制 | 舍入精度之后               | 奇偶 |
| ----------------- | ---------------- | ------ | -------------------------- | ---- |
| Math.pow(2, 53)   | 9007199254740992 | 100000 | 10000                      | 偶   |
| Math.pow(2, 53)+1 | 9007199254740992 | 100001 | 10000(舍了,因为下面为奇数) | 偶   |
| Math.pow(2, 53)+2 | 9007199254740994 | 100010 | 10001                      | 奇   |
| Math.pow(2, 53)+3 | 9007199254740996 | 100011 | 10001(入了,因为上面为奇数) | 奇   |
| Math.pow(2, 53)+4 | 9007199254740996 | 100100 | 10010                      | 偶   |
| Math.pow(2, 53)+5 | 9007199254740996 | 100101 | 10010(舍了,因为下面为奇数) | 偶   |
| Math.pow(2, 53)+6 | 9007199254740998 | 100110 | 10011                      | 奇   |
| Math.pow(2, 53)+7 | 9007199254741000 | 100111 | 10011(入了,因为上面为奇数) | 奇   |
| Math.pow(2, 53)+8 | 9007199254741000 | 101000 | 10100                      | 偶   |

#  取整

## ~~取整

element.style.outline = "1px solid #" + (~~(Math.random() * (1 << 24))).toString(16)

设置element的outline，并且颜色为随机， ~~的作用是在取整

## Math.trunc